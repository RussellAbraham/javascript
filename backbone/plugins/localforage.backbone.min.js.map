{"version":3,"sources":["localforage.backbone.js"],"names":["root","factory","define","amd","module","exports","localforage","require","Backbone","_","this","S4","Math","random","toString","substring","guid","updateCollectionReferences","collection","callback","err","data","collectionData","map","model","prototype","sync","_localforageNamespace","id","partial","undefined","localforageKey","setItem","Collection","idAttribute","attributes","localforageInstance","name","self","method","options","find","findAll","create","update","destroy","_localeForageKeyFn","save","toJSON","callbacks","success","getItem","isEmpty","error","length","done","after","onModel","i","removeItem"],"mappings":"CAgCC,SAASA,EAAMC,GACZ,GAAsB,kBAAXC,SAAyBA,OAAOC,IACvCD,QAAQ,cAAe,WAAY,cAAeD,OAC/C,IAAsB,mBAAXG,SAA0BA,OAAOC,QAAS,CACxD,GAAIC,GAAcC,QAAQ,eACtBC,EAAWD,QAAQ,YACnBE,EAAIF,QAAQ,aAChBH,QAAOC,QAAUJ,EAAQK,EAAaE,EAAUC,OAEhDR,GAAQD,EAAKM,YAAaN,EAAKQ,SAAUR,EAAKS,IAEpDC,KAAM,SAASJ,EAAaE,EAAUC,GACpC,QAASE,KAEL,OAA8B,OAArB,EAAIC,KAAKC,UAAoB,GAAGC,SAAS,IAAIC,UAAU,GAIpE,QAASC,KACL,MAAOL,KAAOA,IAAO,IAAMA,IAAO,IAAMA,IAAO,IAAMA,IAAO,IAAMA,IAAOA,IAAOA,IAGpF,QAASM,GAA2BC,EAAYC,EAAUC,EAAKC,GAG3D,GAAIH,EAAY,CAEZ,GAAII,GAAiBJ,EAAWK,IAAI,SAASC,GACzC,MAAON,GAAWM,MAAMC,UAAUC,KAAKC,sBAAwB,IAAMH,EAAMI,IAK/ET,GAAWA,EAAWV,EAAEoB,QAAQV,EAAUC,EAAKC,OAAQS,GAElDZ,EAAWQ,KAAKK,gBACjBA,EAAeb,GAInBZ,EAAY0B,QAAQd,EAAWQ,KAAKK,eAAgBT,EAAgBH,IAI5E,QAASY,GAAeP,GAGhBA,YAAiBhB,GAASyB,WAC1BT,EAAME,KAAKK,eAAiBP,EAAME,KAAKC,uBAGlCH,EAAMI,KACPJ,EAAMA,EAAMU,aAAeV,EAAMW,WAAWX,EAAMU,aAAelB,KAGrEQ,EAAME,KAAKK,eAAiBP,EAAME,KAAKC,sBAAwB,IAAMH,EAAMI,IAsHnF,MAhHApB,GAASF,aACL8B,oBAAqB9B,EAErBoB,KAAM,SAASW,GACX,GAAIC,GAAO5B,KACPgB,EAAO,SAASa,EAAQf,EAAOgB,GAG/B,OAFAT,EAAeP,GAEPe,GACJ,IAAK,OACD,MAAOf,GAAMI,GAAKU,EAAKG,KAAKjB,EAAOgB,GAAWF,EAAKI,QAAQlB,EAAOgB,EACtE,KAAK,SACD,MAAOF,GAAKK,OAAOnB,EAAOgB,EAC9B,KAAK,SACD,MAAOF,GAAKM,OAAOpB,EAAOgB,EAC9B,KAAK,SACD,MAAOF,GAAKO,QAAQrB,EAAOgB,IAYvC,OANAd,GAAKC,sBAAwBU,EAI7BX,EAAKoB,mBAAqBf,EAEnBL,GAGXqB,KAAM,SAASvB,EAAOL,GAClBb,EAAY0B,QAAQR,EAAME,KAAKK,eAAgBP,EAAMwB,SAAU,SAAS5B,EAAKC,GAErEG,EAAMN,WACND,EAA2BO,EAAMN,WAAYC,EAAUC,EAAKC,GACrDF,GACPA,EAASE,MAKrBsB,OAAQ,SAASnB,EAAOyB,GAGpB,MAAOvC,MAAKkC,OAAOpB,EAAOyB,IAG9BL,OAAQ,SAASpB,EAAOyB,GACpBvC,KAAKqC,KAAKvB,EAAO,SAASH,GAClB4B,EAAUC,SACVD,EAAUC,QAAQ7B,MAK9BoB,KAAM,SAASjB,EAAOyB,GAClB3C,EAAY6C,QAAQ3B,EAAME,KAAKK,eAAgB,SAASX,EAAKC,GACpDD,GAAQX,EAAE2C,QAAQ/B,GAIZ4B,EAAUI,OACjBJ,EAAUI,QAJNJ,EAAUC,SACVD,EAAUC,QAAQ7B,MASlCqB,QAAS,SAASxB,EAAY+B,GAC1B3C,EAAY6C,QAAQjC,EAAWQ,KAAKK,eAAgB,SAASX,EAAKC,GAC9D,IAAKD,GAAOC,GAAQA,EAAKiC,OAAQ,CAC7B,GAAIC,GAAO,WACHN,EAAUC,SACVD,EAAUC,QAAQ7B,GAM1BkC,GAAO9C,EAAE+C,MAAMnC,EAAKiC,OAAQC,EAO5B,KAAK,GALDE,GAAU,SAASC,EAAGtC,EAAKI,GAC3BH,EAAKqC,GAAKlC,EACV+B,KAGKG,EAAI,EAAGA,EAAIrC,EAAKiC,SAAUI,EAC/BpD,EAAY6C,QAAQ9B,EAAKqC,GAAIjD,EAAEoB,QAAQ4B,EAASC,QAGpDrC,MACI4B,EAAUC,SACVD,EAAUC,QAAQ7B,MAMlCwB,QAAS,SAASrB,EAAOyB,GACrB,GAAI/B,GAAaM,EAAMN,UACvBZ,GAAYqD,WAAWnC,EAAME,KAAKK,eAAgB,WAE1Cb,EACAD,EAA2BC,EAAY+B,EAAUC,QAAS,KAAM1B,EAAMwB,UAC/DC,EAAUC,SACjBD,EAAUC,QAAQ1B,EAAMwB,cAMjCxC,EAASF","file":"localforage.backbone.min.js","sourcesContent":["/*!\r\n    localForage Backbone Adapter\r\n    Version 0.6.2\r\n    https://github.com/mozilla/localforage-backbone\r\n    (c) 2014 Mozilla, Apache License 2.0\r\n*/\r\n// backbone.localforage allows users of Backbone.js to store their collections\r\n// entirely offline with no communication to a REST server. It uses whatever\r\n// driver localForage is set to use to store the data (IndexedDB, WebSQL, or\r\n// localStorage, depending on availability). This allows apps on Chrome,\r\n// Firefox, IE, and Safari to use async, offline storage, which is cool.\r\n//\r\n// The basics of how to use this library is that it lets you override the\r\n// `sync` method on your collections and models to use localForage. So\r\n//\r\n//     var MyModel = Backbone.Model.extend({})\r\n//     var MyCollection = Backbone.Collection.extend({\r\n//         model: MyModel\r\n//     });\r\n//\r\n// becomes\r\n//\r\n//     var MyModel = Backbone.Collection.extend({\r\n//         sync: Backbone.localforage.sync('ModelNamespace')\r\n//     });\r\n//     var MyCollection = Backbone.Collection.extend({\r\n//         model: MyModel,\r\n//         sync: Backbone.localforage.sync('MyCollection')\r\n//     });\r\n//\r\n// Inspiration for this file comes from a few backbone.localstorage\r\n// implementations.\r\n(function(root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(['localforage', 'backbone', 'underscore'], factory);\r\n    } else if (typeof module !== 'undefined' && module.exports) {\r\n        var localforage = require('localforage');\r\n        var Backbone = require('backbone');\r\n        var _ = require('underscore');\r\n        module.exports = factory(localforage, Backbone, _);\r\n    } else {\r\n        factory(root.localforage, root.Backbone, root._);\r\n    }\r\n}(this, function(localforage, Backbone, _) {\r\n    function S4() {\r\n        // jshint -W016\r\n        return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);\r\n        // jshint +W016\r\n    }\r\n\r\n    function guid() {\r\n        return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();\r\n    }\r\n\r\n    function updateCollectionReferences(collection, callback, err, data) {\r\n        // If this model has a collection, keep the collection in =\r\n        // sync as well.\r\n        if (collection) {\r\n            // Create an array of `model.collection` models' ids.\r\n            var collectionData = collection.map(function(model) {\r\n                return collection.model.prototype.sync._localforageNamespace + '/' + model.id;\r\n            });\r\n\r\n            // Bind `data` to `callback` to call after\r\n            // `model.collection` models' ids are persisted.\r\n            callback = callback ? _.partial(callback, err, data) : undefined;\r\n\r\n            if (!collection.sync.localforageKey) {\r\n                localforageKey(collection);\r\n            }\r\n\r\n            // Persist `model.collection` models' ids.\r\n            localforage.setItem(collection.sync.localforageKey, collectionData, callback);\r\n        }\r\n    }\r\n\r\n    function localforageKey(model) {\r\n        // If `this` is a `Backbone.Collection` it means\r\n        // `Backbone.Collection#fetch` has been called.\r\n        if (model instanceof Backbone.Collection) {\r\n            model.sync.localforageKey = model.sync._localforageNamespace;\r\n        } else { // `this` is a `Backbone.Model` if not a `Backbone.Collection`.\r\n            // Generate an id if one is not set yet.\r\n            if (!model.id) {\r\n                model[model.idAttribute] = model.attributes[model.idAttribute] = guid();\r\n            }\r\n\r\n            model.sync.localforageKey = model.sync._localforageNamespace + '/' + model.id;\r\n        }\r\n    }\r\n\r\n    // For now, we aren't complicated: just set a property off Backbone to\r\n    // serve as our export point.\r\n    Backbone.localforage = {\r\n        localforageInstance: localforage,\r\n\r\n        sync: function(name) {\r\n            var self = this;\r\n            var sync = function(method, model, options) {\r\n                localforageKey(model);\r\n\r\n                switch (method) {\r\n                    case 'read':\r\n                        return model.id ? self.find(model, options) : self.findAll(model, options);\r\n                    case 'create':\r\n                        return self.create(model, options);\r\n                    case 'update':\r\n                        return self.update(model, options);\r\n                    case 'delete':\r\n                        return self.destroy(model, options);\r\n                }\r\n            };\r\n\r\n            // This needs to be exposed for later usage, but it's private to\r\n            // the adapter.\r\n            sync._localforageNamespace = name;\r\n\r\n            // expose function used to create the localeForage key\r\n            // this enable to have the key set before sync is called\r\n            sync._localeForageKeyFn = localforageKey;\r\n\r\n            return sync;\r\n        },\r\n\r\n        save: function(model, callback) {\r\n            localforage.setItem(model.sync.localforageKey, model.toJSON(), function(err, data) {\r\n                // keep the collection in sync\r\n                if (model.collection) {\r\n                    updateCollectionReferences(model.collection, callback, err, data);\r\n                } else if (callback) {\r\n                    callback(data);\r\n                }\r\n            });\r\n        },\r\n\r\n        create: function(model, callbacks) {\r\n            // We always have an ID available by this point, so we just call\r\n            // the update method.\r\n            return this.update(model, callbacks);\r\n        },\r\n\r\n        update: function(model, callbacks) {\r\n            this.save(model, function(data) {\r\n                if (callbacks.success) {\r\n                    callbacks.success(data);\r\n                }\r\n            });\r\n        },\r\n\r\n        find: function(model, callbacks) {\r\n            localforage.getItem(model.sync.localforageKey, function(err, data) {\r\n                if (!err && !_.isEmpty(data)) {\r\n                    if (callbacks.success) {\r\n                        callbacks.success(data);\r\n                    }\r\n                } else if (callbacks.error) {\r\n                    callbacks.error();\r\n                }\r\n            });\r\n        },\r\n\r\n        // Only used by `Backbone.Collection#sync`.\r\n        findAll: function(collection, callbacks) {\r\n            localforage.getItem(collection.sync.localforageKey, function(err, data) {\r\n                if (!err && data && data.length) {\r\n                    var done = function() {\r\n                        if (callbacks.success) {\r\n                            callbacks.success(data);\r\n                        }\r\n                    };\r\n\r\n                    // Only execute `done` after getting all of the\r\n                    // collection's models.\r\n                    done = _.after(data.length, done);\r\n\r\n                    var onModel = function(i, err, model) {\r\n                        data[i] = model;\r\n                        done();\r\n                    };\r\n\r\n                    for (var i = 0; i < data.length; ++i) {\r\n                        localforage.getItem(data[i], _.partial(onModel, i));\r\n                    }\r\n                } else {\r\n                    data = [];\r\n                    if (callbacks.success) {\r\n                        callbacks.success(data);\r\n                    }\r\n                }\r\n            });\r\n        },\r\n\r\n        destroy: function(model, callbacks) {\r\n            var collection = model.collection;\r\n            localforage.removeItem(model.sync.localforageKey, function() {\r\n                // keep the collection in sync\r\n                if (collection) {\r\n                    updateCollectionReferences(collection, callbacks.success, null, model.toJSON());\r\n                } else if (callbacks.success) {\r\n                    callbacks.success(model.toJSON());\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    return Backbone.localforage;\r\n}));\r\n"]}